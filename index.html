<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas Game</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background-color: #e6f3ff;
            color: #333;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }

        #game-container {
            width: 100%;
            max-width: 700px;
            background-color: #fff;
            border-radius: 25px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
            padding: 40px;
            box-sizing: border-box;
        }

        .page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 450px;
        }

        .page.active {
            display: flex;
        }

        h1 {
            font-size: 3em;
            color: #ff4500;
            margin-bottom: 15px;
        }

        h2 {
            font-size: 2.2em;
            color: #008080;
            margin-top: 0;
        }

        p {
            font-size: 1.3em;
        }

        button {
            background-color: #ff6347;
            color: white;
            border: none;
            padding: 15px 35px;
            margin: 12px;
            font-size: 1.3em;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }

        button:hover {
            background-color: #e5533d;
            transform: scale(1.05);
        }

        #category-buttons button {
            background-color: #32cd32;
        }

        #category-buttons button:hover {
            background-color: #28a745;
        }

        #question-text {
            font-size: 2em;
            font-weight: bold;
            color: #ff4500;
            margin-bottom: 25px;
        }

        #image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-top: 25px;
        }

        .canvas-option {
            background-color: #f0f8ff;
            border: 5px solid transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.3s, border-color 0.3s;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .canvas-option canvas {
            width: 120px;
            height: 120px;
        }

        .canvas-option:hover {
            animation: bounce 0.5s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        .canvas-option.correct {
            border-color: #32cd32;
            animation: pulse 0.5s ease-in-out 2;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .canvas-option.wrong {
            border-color: #ff4500;
        }

        #coloring-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #coloring-canvas {
            width: 100%;
            max-width: 300px;
            border: 3px solid #333;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ccc;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .color-swatch.active {
            transform: scale(1.15);
            border-color: #333;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #fff;
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        .modal-content h3 {
            margin: 0 0 15px;
            color: #333;
            font-size: 1.5em;
        }

        .image-label {
            font-size: 1.1em;
            font-weight: bold;
            text-transform: uppercase;
            color: #ff4500;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu" class="page active">
            <h1>Interactive Game</h1>
            <p>Ready to have some fun?</p>
            <button onclick="startGame()">Start Playing</button>
        </div>

        <div id="categories" class="page">
            <h2>Choose a Category</h2>
            <div id="category-buttons">
                <button onclick="selectCategory('shapes')">Shapes</button>
                <button onclick="selectCategory('buildings_cars')">Buildings & Cars</button>
            </div>
        </div>

        <div id="game-page" class="page">
            <h2 id="game-title"></h2>
            <p id="question-text"></p>
            <div id="image-grid"></div>
            <div id="coloring-area" style="display: none;">
                <p>Color it in!</p>
                <div class="color-palette">
                    <div class="color-swatch active" style="background-color: #ff4500;" data-color="#ff4500"></div>
                    <div class="color-swatch" style="background-color: #00ff00;" data-color="#00ff00"></div>
                    <div class="color-swatch" style="background-color: #1e90ff;" data-color="#1e90ff"></div>
                    <div class="color-swatch" style="background-color: #ffff00;" data-color="#ffff00"></div>
                </div>
                <canvas id="coloring-canvas" width="300" height="300"></canvas>
            </div>
        </div>
    </div>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <h3 id="modal-text"></h3>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        // --- Game Logic ---
        const pages = document.querySelectorAll('.page');
        const modal = document.getElementById('myModal');
        const modalText = document.getElementById('modal-text');
        
        let currentCategory = '';
        let currentQuestionIndex = 0;
        let isCorrect = false;
        let selectedColor = '#ff4500';
        let partsColored = new Set();
        let currentImageParts = [];
        let coloringAnimationId = null; // To store the animation frame ID

        // Helper to convert hex to RGB
        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        // Helper to convert RGB to hex
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        // Image Data: Drawing functions for each shape
        const gameDrawings = {
            'apple': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#333', '#666', '#999'].slice(0, 3).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] || '#333' },
                    { name: 'leaf', path: new Path2D(), color: defaultColors[1] || '#666' },
                    { name: 'stem', path: new Path2D(), color: defaultColors[2] || '#999' }
                ];

                parts[0].path.moveTo(150, 45); parts[0].path.bezierCurveTo(225, 45, 270, 105, 270, 165); parts[0].path.bezierCurveTo(270, 225, 210, 270, 150, 270); parts[0].path.bezierCurveTo(90, 270, 30, 225, 30, 165); parts[0].path.bezierCurveTo(30, 105, 75, 45, 150, 45);
                parts[1].path.moveTo(165, 45); parts[1].path.bezierCurveTo(180, 30, 210, 30, 225, 45); parts[1].path.bezierCurveTo(210, 60, 180, 60, 165, 45);
                parts[2].path.moveTo(143, 75); parts[2].path.bezierCurveTo(135, 45, 165, 45, 158, 75);

                return parts;
            },
            'triangle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(270, 270); path.lineTo(30, 270); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#333' }];
            },
            'circle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.arc(150, 150, 128, 0, 2 * Math.PI);
                return [{ name: 'shape', path: path, color: defaultColor || '#333' }];
            },
            'square': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.rect(22, 22, 256, 256);
                return [{ name: 'shape', path: path, color: defaultColor || '#333' }];
            },
            'star': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(180, 110); path.lineTo(260, 110); path.lineTo(200, 160); path.lineTo(220, 240); path.lineTo(150, 200); path.lineTo(80, 240); path.lineTo(100, 160); path.lineTo(40, 110); path.lineTo(120, 110); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#333' }];
            },
            'house': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#333', '#666', '#999', '#ccc', '#eee', '#bbb'].slice(0, 6).fill(colors);
                const parts = [
                    { name: 'roof', path: new Path2D(), color: defaultColors[0] || '#333' },
                    { name: 'walls', path: new Path2D(), color: defaultColors[1] || '#666' },
                    { name: 'door', path: new Path2D(), color: defaultColors[2] || '#999' },
                    { name: 'window1', path: new Path2D(), color: defaultColors[3] || '#ccc' },
                    { name: 'window2', path: new Path22D(), color: defaultColors[4] || '#eee' },
                    { name: 'chimney', path: new Path2D(), color: defaultColors[5] || '#bbb' }
                ];
                parts[0].path.moveTo(150, 45); parts[0].path.lineTo(30, 135); parts[0].path.lineTo(270, 135); parts[0].path.closePath();
                parts[1].path.rect(45, 135, 210, 135);
                parts[2].path.rect(120, 210, 60, 60);
                parts[3].path.rect(75, 165, 38, 38);
                parts[4].path.rect(188, 165, 38, 38);
                parts[5].path.rect(210, 135, 22, 30);
                return parts;
            },
            'castle': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#333', '#666', '#999', '#ccc', '#eee', '#bbb'].slice(0, 6).fill(colors);
                const parts = [
                    { name: 'mainWall', path: new Path2D(), color: defaultColors[0] || '#333' },
                    { name: 'leftTower', path: new Path2D(), color: defaultColors[1] || '#666' },
                    { name: 'rightTower', path: new Path2D(), color: defaultColors[2] || '#999' },
                    { name: 'flag', path: new Path2D(), color: defaultColors[3] || '#ccc' },
                    { name: 'window1', path: new Path2D(), color: defaultColors[4] || '#eee' },
                    { name: 'window2', path: new Path2D(), color: defaultColors[5] || '#bbb' }
                ];
                parts[0].path.rect(60, 100, 180, 180);
                parts[1].path.rect(30, 45, 60, 235);
                parts[2].path.rect(210, 45, 60, 235);
                parts[3].path.moveTo(250, 60); parts[3].path.lineTo(265, 45); parts[3].path.lineTo(280, 60); parts[3].path.lineTo(265, 75); parts[3].path.closePath();
                parts[4].path.rect(80, 140, 25, 25);
                parts[5].path.rect(195, 140, 25, 25);
                return parts;
            },
            'car': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#333', '#666', '#999', '#ccc'].slice(0, 4).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] || '#333' },
                    { name: 'roof', path: new Path22D(), color: defaultColors[1] || '#666' },
                    { name: 'frontWheel', path: new Path2D(), color: defaultColors[2] || '#999' },
                    { name: 'backWheel', path: new Path2D(), color: defaultColors[3] || '#ccc' }
                ];
                parts[0].path.moveTo(30, 180); parts[0].path.lineTo(270, 180); parts[0].path.lineTo(270, 240); parts[0].path.lineTo(30, 240); parts[0].path.closePath();
                parts[1].path.moveTo(75, 180); parts[1].path.lineTo(135, 120); parts[1].path.lineTo(225, 120); parts[1].path.lineTo(240, 180); parts[1].path.closePath();
                parts[2].path.arc(90, 240, 30, 0, 2 * Math.PI);
                parts[3].path.arc(210, 240, 30, 0, 2 * Math.PI);
                return parts;
            },
            'tree': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#333', '#666'].slice(0, 2).fill(colors);
                const parts = [
                    { name: 'trunk', path: new Path2D(), color: defaultColors[0] || '#333' },
                    { name: 'leaves', path: new Path2D(), color: defaultColors[1] || '#666' }
                ];
                parts[0].path.rect(125, 180, 50, 90);
                parts[1].path.arc(150, 150, 120, 0, 2 * Math.PI);
                return parts;
            }
        };

        const gameData = {
            shapes: [
                {
                    question: "APPLE",
                    answer: "apple",
                    images: ['apple', 'triangle', 'circle', 'square']
                },
                {
                    question: "TRIANGLE",
                    answer: "triangle",
                    images: ['circle', 'square', 'triangle', 'star']
                }
            ],
            buildings_cars: [
                {
                    question: "CASTLE",
                    answer: "castle",
                    images: ['house', 'castle', 'car', 'tree']
                },
                {
                    question: "CAR",
                    answer: "car",
                    images: ['car', 'house', 'castle', 'tree']
                }
            ]
        };

        // UI Functions
        function changePage(id) {
            pages.forEach(page => page.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }
        
        function startGame() {
            changePage('categories');
        }

        function showModal(text, duration = 1500) {
            modalText.innerHTML = text;
            modal.style.display = 'flex';
            setTimeout(closeModal, duration);
        }
        
        function closeModal() {
            modal.style.display = 'none';
        }

        // Game Logic
        function selectCategory(category) {
            currentCategory = category;
            currentQuestionIndex = 0;
            document.getElementById('game-title').innerText = `Category: ${category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' & ')}`;
            changePage('game-page');
            loadQuestion();
        }

        function loadQuestion() {
            if (currentQuestionIndex >= gameData[currentCategory].length) {
                showModal("You finished the game! Great job! ðŸŽ‰", 3000);
                setTimeout(() => changePage('menu'), 3000);
                return;
            }

            const questionData = gameData[currentCategory][currentQuestionIndex];
            document.getElementById('question-text').innerText = questionData.question;
            const grid = document.getElementById('image-grid');
            grid.innerHTML = '';
            
            const shuffledImages = questionData.images.sort(() => Math.random() - 0.5);

            shuffledImages.forEach(imageName => {
                const div = document.createElement('div');
                div.classList.add('canvas-option');
                div.dataset.answer = imageName;

                const canvas = document.createElement('canvas');
                const canvasSize = 200; // Larger canvas for better quality
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const ctx = canvas.getContext('2d');
                ctx.scale(canvasSize / 300, canvasSize / 300); // Scale down to fit in 200x200 while maintaining drawing coordinates

                // Draw solid black shapes for the quiz
                const parts = gameDrawings[imageName](ctx, '#000');
                parts.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.fill(part.path);
                });

                const label = document.createElement('span');
                label.classList.add('image-label');
                label.innerText = imageName.toUpperCase();
                div.prepend(label);

                div.appendChild(canvas);
                div.onclick = () => checkAnswer(imageName, questionData.answer, div);
                grid.appendChild(div);
            });

            document.getElementById('image-grid').style.display = 'grid';
            document.getElementById('coloring-area').style.display = 'none';
            isCorrect = false;
        }

        function checkAnswer(selected, correct, element) {
            if (isCorrect) return;

            if (selected.includes(correct)) {
                isCorrect = true;
                element.classList.add('correct');
                showModal("Correct! Great job!", 1000);
                playSound(800, 0.1);
                
                document.getElementById('image-grid').style.display = 'none';
                document.getElementById('coloring-area').style.display = 'flex';
                
                const coloringCanvas = document.getElementById('coloring-canvas');
                const ctx = coloringCanvas.getContext('2d');
                ctx.clearRect(0, 0, coloringCanvas.width, coloringCanvas.height);

                // Initial shades for parts in coloring screen
                const shades = ['#444', '#666', '#888', '#aaa', '#ccc', '#eee']; // Different shades of grey
                currentImageParts = gameDrawings[correct](ctx, shades); // Pass shades for initial drawing
                
                // Draw all parts with their initial grey shades
                currentImageParts.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.strokeStyle = '#333'; // Outline for each part
                    ctx.lineWidth = 2;
                    ctx.fill(part.path);
                    ctx.stroke(part.path);
                });

                // Clear any ongoing animation
                if (coloringAnimationId) {
                    cancelAnimationFrame(coloringAnimationId);
                }

                // Add click listener for coloring
                coloringCanvas.onclick = (event) => {
                    const rect = coloringCanvas.getBoundingClientRect();
                    const x = (event.clientX - rect.left) * (coloringCanvas.width / rect.width);
                    const y = (event.clientY - rect.top) * (coloringCanvas.height / rect.height);

                    currentImageParts.forEach(part => {
                        if (ctx.isPointInPath(part.path, x, y) && !partsColored.has(part.name)) {
                            partsColored.add(part.name);
                            playSound(440, 0.05);
                            animateColorFill(ctx, part, selectedColor);
                        }
                    });

                    // Check if all parts are colored AFTER animation potentially starts
                    // This check will be moved to the end of the animation
                };

                partsColored = new Set();
            } else {
                element.classList.add('wrong');
                showModal("Oops! Try again!", 1000);
                playSound(200, 0.3, 'sawtooth');
                setTimeout(() => element.classList.remove('wrong'), 1000);
            }
        }

        // Animation function for gradual color fill
        function animateColorFill(ctx, part, targetColor) {
            const startColorRgb = hexToRgb(part.color);
            const targetColorRgb = hexToRgb(targetColor);
            const duration = 500; // milliseconds
            const startTime = performance.now();

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const r = Math.round(startColorRgb.r + (targetColorRgb.r - startColorRgb.r) * progress);
                const g = Math.round(startColorRgb.g + (targetColorRgb.g - startColorRgb.g) * progress);
                const b = Math.round(startColorRgb.b + (targetColorRgb.b - startColorRgb.b) * progress);
                
                part.color = rgbToHex(r, g, b);

                // Redraw all parts to show animation
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                currentImageParts.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.fill(p.path);
                    ctx.stroke(p.path);
                });

                if (progress < 1) {
                    coloringAnimationId = requestAnimationFrame(animate);
                } else {
                    // Animation finished
                    if (partsColored.size === currentImageParts.length) {
                        showModal("All done! Next one!", 1500);
                        setTimeout(nextQuestion, 1500);
                    }
                }
            };

            coloringAnimationId = requestAnimationFrame(animate);
        }


        function nextQuestion() {
            currentQuestionIndex++;
            loadQuestion();
        }
        
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.onclick = () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                selectedColor = swatch.dataset.color;
            };
        });

        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            oscillator.start();
            setTimeout(() => oscillator.stop(), duration * 1000);
        }
    </script>
</body>
</html>
