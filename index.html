<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas Game</title>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulseBorder {
            0% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
            50% { transform: scale(1.02); box-shadow: 0 0 20px rgba(0, 255, 255, 1); }
            100% { transform: scale(1); box-shadow: 0 0 10px rgba(0, 255, 255, 0.7); }
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            max-width: 700px;
            background-color: #111;
            border-radius: 25px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.5);
            padding: 40px;
            box-sizing: border-box;
            animation: fadeIn 1s ease-out;
        }

        .page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 450px;
        }

        .page.active {
            display: flex;
        }

        h1 {
            font-size: 3em;
            color: #ff4500;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ff4500;
        }

        h2 {
            font-size: 2.2em;
            color: #00ffff;
            margin-top: 0;
            text-shadow: 0 0 8px #00ffff;
        }

        p {
            font-size: 1.3em;
        }

        button {
            background-color: #ff6347;
            color: white;
            border: none;
            padding: 15px 35px;
            margin: 12px;
            font-size: 1.3em;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 0 10px rgba(255, 99, 71, 0.5);
        }

        button:hover {
            background-color: #e5533d;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 99, 71, 0.8);
        }

        #category-buttons button {
            background-color: #32cd32;
            box-shadow: 0 0 10px rgba(50, 205, 50, 0.5);
        }

        #category-buttons button:hover {
            background-color: #28a745;
            box-shadow: 0 0 20px rgba(50, 205, 50, 0.8);
        }

        #question-text {
            font-size: 2em;
            font-weight: bold;
            color: #ff4500;
            margin-bottom: 25px;
            text-shadow: 0 0 8px #ff4500;
            animation: fadeIn 1s ease-in-out;
        }

        #image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-top: 25px;
        }

        .canvas-option {
            background-color: #222;
            border: 5px solid transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 1s ease-out;
        }

        .canvas-option canvas {
            width: 120px;
            height: 120px;
        }

        .canvas-option:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .canvas-option.correct {
            border-color: #32cd32;
            box-shadow: 0 0 20px #32cd32;
            animation: pulse 0.5s ease-in-out 2;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .canvas-option.wrong {
            border-color: #ff4500;
            box-shadow: 0 0 20px #ff4500;
        }

        #coloring-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 1s ease-out;
        }

        #coloring-canvas {
            width: 100%;
            max-width: 300px;
            background-color: #222;
            border: 3px solid #333;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #ccc;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .color-swatch.active {
            transform: scale(1.15);
            border-color: #fff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #111;
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 5px 25px rgba(0, 255, 255, 0.3);
            text-align: center;
            animation: pulseBorder 2s infinite;
        }

        .modal-content h3 {
            margin: 0 0 15px;
            color: #fff;
            font-size: 1.5em;
        }

        .image-label {
            font-size: 1.1em;
            font-weight: bold;
            text-transform: uppercase;
            color: #ff4500;
            margin-top: 8px;
        }

        /* Animation for parts that need coloring */
        .colorable-part {
            animation: pulse-part 1.5s infinite;
        }

        @keyframes pulse-part {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu" class="page active">
            <h1>Interactive Game</h1>
            <p>Ready to have some fun?</p>
            <button onclick="startGame()">Start Playing</button>
        </div>

        <div id="categories" class="page">
            <h2>Choose a Category</h2>
            <div id="category-buttons">
                <button onclick="selectCategory('shapes')">Shapes</button>
                <button onclick="selectCategory('buildings_cars')">Buildings & Cars</button>
            </div>
        </div>

        <div id="game-page" class="page">
            <h2 id="game-title"></h2>
            <p id="question-text"></p>
            <div id="image-grid"></div>
            <div id="coloring-area" style="display: none;">
                <p>Color it in!</p>
                <div class="color-palette">
                    <div class="color-swatch active" style="background-color: #ff4500;" data-color="#ff4500"></div>
                    <div class="color-swatch" style="background-color: #00ff00;" data-color="#00ff00"></div>
                    <div class="color-swatch" style="background-color: #1e90ff;" data-color="#1e90ff"></div>
                    <div class="color-swatch" style="background-color: #ffff00;" data-color="#ffff00"></div>
                </div>
                <canvas id="coloring-canvas" width="300" height="300"></canvas>
            </div>
        </div>
    </div>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <h3 id="modal-text"></h3>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        const pages = document.querySelectorAll('.page');
        const modal = document.getElementById('myModal');
        const modalText = document.getElementById('modal-text');
        
        let currentCategory = '';
        let currentQuestionIndex = 0;
        let isCorrect = false;
        let selectedColor = '#ff4500';
        let partsColored = new Set();
        let currentImageParts = [];
        let coloringAnimationId = null;

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function getRandomColor() {
            const colors = ['#ff4500', '#00ff00', '#1e90ff', '#ffff00', '#9400d3'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        const gameDrawings = {
            'apple': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#808080', '#A9A9A9', '#C0C0C0'].slice(0, 3).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] || '#808080', outline: true },
                    { name: 'leaf', path: new Path2D(), color: defaultColors[1] || '#A9A9A9', outline: true },
                    { name: 'stem', path: new Path2D(), color: defaultColors[2] || '#C0C0C0', outline: true }
                ];
                parts[0].path.moveTo(150, 45); parts[0].path.bezierCurveTo(225, 45, 270, 105, 270, 165); parts[0].path.bezierCurveTo(270, 225, 210, 270, 150, 270); parts[0].path.bezierCurveTo(90, 270, 30, 225, 30, 165); parts[0].path.bezierCurveTo(30, 105, 75, 45, 150, 45);
                parts[1].path.moveTo(165, 45); parts[1].path.bezierCurveTo(180, 30, 210, 30, 225, 45); parts[1].path.bezierCurveTo(210, 60, 180, 60, 165, 45);
                parts[2].path.moveTo(143, 75); parts[2].path.bezierCurveTo(135, 45, 165, 45, 158, 75);
                return parts;
            },
            'triangle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(270, 270); path.lineTo(30, 270); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#808080', outline: true }];
            },
            'circle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.arc(150, 150, 128, 0, 2 * Math.PI);
                return [{ name: 'shape', path: path, color: defaultColor || '#808080', outline: true }];
            },
            'square': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.rect(22, 22, 256, 256);
                return [{ name: 'shape', path: path, color: defaultColor || '#808080', outline: true }];
            },
            'star': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(180, 110); path.lineTo(260, 110); path.lineTo(200, 160); path.lineTo(220, 240); path.lineTo(150, 200); path.lineTo(80, 240); path.lineTo(100, 160); path.lineTo(40, 110); path.lineTo(120, 110); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#808080', outline: true }];
            },
            'house': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3', '#E0E0E0'].slice(0, 5).fill(colors);
                const parts = [
                    { name: 'roof', path: new Path2D(), color: defaultColors[0] || '#808080', outline: true },
                    { name: 'walls', path: new Path2D(), color: defaultColors[1] || '#A9A9A9', outline: true },
                    { name: 'door', path: new Path2D(), color: defaultColors[2] || '#C0C0C0', outline: true },
                    { name: 'window1', path: new Path2D(), color: defaultColors[3] || '#D3D3D3', outline: true },
                    { name: 'window2', path: new Path2D(), color: defaultColors[4] || '#E0E0E0', outline: true },
                ];
                parts[0].path.moveTo(150, 45); parts[0].path.lineTo(30, 135); parts[0].path.lineTo(270, 135); parts[0].path.closePath();
                parts[1].path.rect(45, 135, 210, 135);
                parts[2].path.rect(120, 210, 60, 60);
                parts[3].path.rect(75, 165, 38, 38);
                parts[4].path.rect(188, 165, 38, 38);
                return parts;
            },
            'castle': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3', '#E0E0E0'].slice(0, 5).fill(colors);
                const parts = [
                    { name: 'mainWall', path: new Path2D(), color: defaultColors[0] || '#808080', outline: true },
                    { name: 'leftTower', path: new Path2D(), color: defaultColors[1] || '#A9A9A9', outline: true },
                    { name: 'rightTower', path: new Path2D(), color: defaultColors[2] || '#C0C0C0', outline: true },
                    { name: 'flag', path: new Path2D(), color: defaultColors[3] || '#D3D3D3', outline: true },
                    { name: 'door', path: new Path2D(), color: defaultColors[4] || '#E0E0E0', outline: true },
                ];
                parts[0].path.rect(60, 100, 180, 180);
                parts[1].path.rect(30, 45, 60, 235);
                parts[2].path.rect(210, 45, 60, 235);
                parts[3].path.moveTo(250, 60); parts[3].path.lineTo(265, 45); parts[3].path.lineTo(280, 60); parts[3].path.lineTo(265, 75); parts[3].path.closePath();
                parts[4].path.rect(130, 200, 40, 80);
                return parts;
            },
            'car': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#808080', '#A9A9A9', '#C0C0C0', '#D3D3D3', '#E0E0E0'].slice(0, 5).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] || '#808080', outline: true },
                    { name: 'roof', path: new Path2D(), color: defaultColors[1] || '#A9A9A9', outline: true },
                    { name: 'frontWheel', path: new Path2D(), color: defaultColors[2] || '#C0C0C0', outline: true },
                    { name: 'backWheel', path: new Path2D(), color: defaultColors[3] || '#D3D3D3', outline: true },
                    { name: 'window', path: new Path2D(), color: defaultColors[4] || '#E0E0E0', outline: true },
                ];
                parts[0].path.moveTo(30, 180); parts[0].path.lineTo(270, 180); parts[0].path.lineTo(270, 240); parts[0].path.lineTo(30, 240); parts[0].path.closePath();
                parts[1].path.moveTo(75, 180); parts[1].path.lineTo(135, 120); parts[1].path.lineTo(225, 120); parts[1].path.lineTo(240, 180); parts[1].path.closePath();
                parts[2].path.arc(90, 240, 30, 0, 2 * Math.PI);
                parts[3].path.arc(210, 240, 30, 0, 2 * Math.PI);
                parts[4].path.rect(90, 130, 100, 30);
                return parts;
            },
            'tree': (ctx, colors) => {
                const defaultColors = Array.isArray(colors) ? colors : ['#808080', '#A9A9A9'].slice(0, 2).fill(colors);
                const parts = [
                    { name: 'trunk', path: new Path2D(), color: defaultColors[0] || '#808080', outline: true },
                    { name: 'leaves', path: new Path2D(), color: defaultColors[1] || '#A9A9A9', outline: true }
                ];
                parts[0].path.rect(125, 180, 50, 90);
                parts[1].path.arc(150, 150, 120, 0, 2 * Math.PI);
                return parts;
            }
        };

        const gameData = {
            shapes: [
                {
                    question: "APPLE",
                    answer: "apple",
                    images: ['apple', 'triangle', 'circle', 'square']
                },
                {
                    question: "TRIANGLE",
                    answer: "triangle",
                    images: ['circle', 'square', 'triangle', 'star']
                }
            ],
            buildings_cars: [
                {
                    question: "CASTLE",
                    answer: "castle",
                    images: ['house', 'castle', 'car', 'tree']
                },
                {
                    question: "CAR",
                    answer: "car",
                    images: ['car', 'house', 'castle', 'tree']
                }
            ]
        };

        function changePage(id) {
            pages.forEach(page => page.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }
        
        function startGame() {
            changePage('categories');
        }

        function showModal(text, duration = 1500) {
            modalText.innerHTML = text;
            modal.style.display = 'flex';
            setTimeout(closeModal, duration);
        }
        
        function closeModal() {
            modal.style.display = 'none';
        }

        function selectCategory(category) {
            currentCategory = category;
            currentQuestionIndex = 0;
            document.getElementById('game-title').innerText = `Category: ${category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' & ')}`;
            changePage('game-page');
            loadQuestion();
        }

        function loadQuestion() {
            if (currentQuestionIndex >= gameData[currentCategory].length) {
                showModal("You finished the game! Great job! 🎉", 3000);
                setTimeout(() => changePage('menu'), 3000);
                return;
            }

            const questionData = gameData[currentCategory][currentQuestionIndex];
            document.getElementById('question-text').innerText = `Which one is a ${questionData.answer.toUpperCase()}?`;
            const grid = document.getElementById('image-grid');
            grid.innerHTML = '';
            
            const shuffledImages = questionData.images.sort(() => Math.random() - 0.5);
            
            shuffledImages.forEach(imageName => {
                const div = document.createElement('div');
                div.classList.add('canvas-option');
                div.dataset.answer = imageName;

                const canvas = document.createElement('canvas');
                const canvasSize = 200; 
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const ctx = canvas.getContext('2d');
                ctx.scale(canvasSize / 300, canvasSize / 300);

                const randomColor = getRandomColor();
                const parts = gameDrawings[imageName](ctx, randomColor);
                parts.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.fill(part.path);
                    if (part.outline) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 10;
                        ctx.stroke(part.path);
                    }
                });

                const label = document.createElement('span');
                label.classList.add('image-label');
                label.innerText = `${randomColorName(randomColor).toUpperCase()} ${imageName.toUpperCase()}`;
                div.prepend(label);

                div.appendChild(canvas);
                div.onclick = () => checkAnswer(imageName, questionData.answer, div);
                grid.appendChild(div);
            });

            document.getElementById('image-grid').style.display = 'grid';
            document.getElementById('coloring-area').style.display = 'none';
            isCorrect = false;
        }

        function randomColorName(hex) {
            const colorMap = {
                '#ff4500': 'RED',
                '#00ff00': 'GREEN',
                '#1e90ff': 'BLUE',
                '#ffff00': 'YELLOW',
                '#9400d3': 'PURPLE'
            };
            return colorMap[hex] || 'UNKNOWN';
        }

        function checkAnswer(selected, correct, element) {
            if (isCorrect) return;

            if (selected.includes(correct)) {
                isCorrect = true;
                element.classList.add('correct');
                showModal("Correct! Great job!", 1000);
                playSound(800, 0.1);
                
                document.getElementById('image-grid').style.display = 'none';
                document.getElementById('coloring-area').style.display = 'flex';
                
                const coloringCanvas = document.getElementById('coloring-canvas');
                const ctx = coloringCanvas.getContext('2d');
                ctx.clearRect(0, 0, coloringCanvas.width, coloringCanvas.height);

                const shades = ['#444', '#666', '#888', '#aaa', '#bbb']; 
                currentImageParts = gameDrawings[correct](ctx, shades);
                
                currentImageParts.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.fill(part.path);
                    if (part.outline) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke(part.path);
                    }
                });

                if (coloringAnimationId) {
                    cancelAnimationFrame(coloringAnimationId);
                }

                coloringCanvas.onclick = (event) => {
                    const rect = coloringCanvas.getBoundingClientRect();
                    const x = (event.clientX - rect.left) * (coloringCanvas.width / rect.width);
                    const y = (event.clientY - rect.top) * (coloringCanvas.height / rect.width);

                    currentImageParts.forEach(part => {
                        if (ctx.isPointInPath(part.path, x, y) && !partsColored.has(part.name)) {
                            partsColored.add(part.name);
                            playSound(440, 0.05);
                            animateColorFill(ctx, part, selectedColor);
                        }
                    });
                };

                partsColored = new Set();
                animateColorableParts(ctx);
            } else {
                element.classList.add('wrong');
                showModal("Oops! Try again!", 1000);
                playSound(200, 0.3, 'sawtooth');
                setTimeout(() => element.classList.remove('wrong'), 1000);
            }
        }

        function animateColorFill(ctx, part, targetColor) {
            const startColorRgb = hexToRgb(part.color);
            const targetColorRgb = hexToRgb(targetColor);
            const duration = 500;
            const startTime = performance.now();
            let isAnimating = true;

            const animate = (currentTime) => {
                if (!isAnimating) return;

                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const r = Math.round(startColorRgb.r + (targetColorRgb.r - startColorRgb.r) * progress);
                const g = Math.round(startColorRgb.g + (targetColorRgb.g - startColorRgb.g) * progress);
                const b = Math.round(startColorRgb.b + (targetColorRgb.b - startColorRgb.b) * progress);
                
                part.color = rgbToHex(r, g, b);

                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                currentImageParts.forEach(p => {
                    ctx.fillStyle = p.color;
                    ctx.fill(p.path);
                    if (p.outline) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke(p.path);
                    }
                });
                
                if (progress < 1) {
                    coloringAnimationId = requestAnimationFrame(animate);
                } else {
                    isAnimating = false;
                    if (partsColored.size === currentImageParts.length) {
                        showModal("All done! Next one!", 1500);
                        setTimeout(nextQuestion, 1500);
                    }
                }
            };
            coloringAnimationId = requestAnimationFrame(animate);
        }

        let animationFrameId = null;
        function animateColorableParts(ctx) {
            function animate(timestamp) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                const time = timestamp * 0.001;
                currentImageParts.forEach(part => {
                    ctx.fillStyle = part.color;
                    ctx.fill(part.path);
                    if (part.outline) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke(part.path);
                    }

                    if (!partsColored.has(part.name)) {
                        const scale = 1 + Math.sin(time * 2) * 0.03;
                        const opacity = 0.9 + Math.sin(time * 2) * 0.1;
                        ctx.save();
                        ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
                        ctx.scale(scale, scale);
                        ctx.translate(-ctx.canvas.width / 2, -ctx.canvas.height / 2);
                        ctx.fillStyle = `rgba(${hexToRgb(part.color).r}, ${hexToRgb(part.color).g}, ${hexToRgb(part.color).b}, ${opacity})`;
                        ctx.fill(part.path);
                        ctx.restore();
                    }
                });
                animationFrameId = requestAnimationFrame(animate);
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        function nextQuestion() {
            currentQuestionIndex++;
            loadQuestion();
        }
        
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.onclick = () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                selectedColor = swatch.dataset.color;
            };
        });

        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            oscillator.start();
            setTimeout(() => oscillator.stop(), duration * 1000);
        }
    </script>
</body>
</html>
