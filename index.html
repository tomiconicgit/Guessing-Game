<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Canvas Game</title>
    <style>
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        body {
            font-family: 'Comic Sans MS', 'Arial', sans-serif;
            background-color: #121212; /* Dark background */
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
        }

        #game-container {
            width: 100%;
            max-width: 700px;
            background-color: #1e1e1e;
            border-radius: 25px;
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.5);
            padding: 40px;
            box-sizing: border-box;
            animation: fadeIn 1s ease-out;
        }

        .page {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 450px;
        }

        .page.active {
            display: flex;
        }

        h1 {
            font-size: 3em;
            color: #ff6f61; /* Vibrant Orange-Red */
            margin-bottom: 15px;
        }

        h2 {
            font-size: 2.2em;
            color: #4db6ac; /* Teal */
            margin-top: 0;
        }

        p {
            font-size: 1.3em;
            color: #b0b0b0;
        }

        button {
            background-color: #ff8a65; /* Light Coral */
            color: white;
            border: none;
            padding: 15px 35px;
            margin: 12px;
            font-size: 1.3em;
            border-radius: 12px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        button:hover {
            background-color: #e5735b;
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
        }

        #category-buttons button {
            background-color: #81c784; /* Light Green */
        }

        #category-buttons button:hover {
            background-color: #66bb6a;
        }

        #question-text {
            font-size: 2em;
            font-weight: bold;
            color: #ff6f61;
            margin-bottom: 25px;
            animation: fadeIn 1s ease-in-out;
        }

        #image-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-top: 25px;
        }

        .canvas-option {
            background-color: #2e2e2e;
            border: 5px solid transparent;
            border-radius: 20px;
            cursor: pointer;
            transition: transform 0.3s, border-color 0.3s, box-shadow 0.3s;
            padding: 15px;
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 1s ease-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .canvas-option canvas {
            width: 120px;
            height: 120px;
        }

        .canvas-option:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        .canvas-option.correct {
            border-color: #66bb6a;
            box-shadow: 0 0 20px #66bb6a;
            animation: pulse 0.5s ease-in-out 2;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .canvas-option.wrong {
            border-color: #ff6f61;
            box-shadow: 0 0 20px #ff6f61;
        }

        #coloring-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            animation: fadeIn 1s ease-out;
        }

        #coloring-canvas {
            width: 100%;
            max-width: 300px;
            background-color: #1e1e1e;
            border: 3px solid #66bb6a;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            margin-bottom: 25px;
        }

        .color-swatch {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: 3px solid #b0b0b0;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .color-swatch.active {
            transform: scale(1.15);
            border-color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.4);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: #1e1e1e;
            padding: 35px;
            border-radius: 20px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .modal-content h3 {
            margin: 0 0 15px;
            color: #e0e0e0;
            font-size: 1.5em;
        }

        .image-label {
            font-size: 1.1em;
            font-weight: bold;
            text-transform: uppercase;
            color: #ff6f61;
            margin-top: 8px;
        }

        .colorable-part {
            animation: pulse-part 1.5s infinite;
        }
        @keyframes pulse-part {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.03); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu" class="page active">
            <h1>Interactive Game</h1>
            <p>Ready to have some fun?</p>
            <button onclick="startGame()">Start Playing</button>
        </div>

        <div id="categories" class="page">
            <h2>Choose a Category</h2>
            <div id="category-buttons">
                <button onclick="selectCategory('shapes')">Shapes</button>
                <button onclick="selectCategory('buildings_cars')">Buildings & Cars</button>
            </div>
        </div>

        <div id="game-page" class="page">
            <h2 id="game-title"></h2>
            <p id="question-text"></p>
            <div id="image-grid"></div>
            <div id="coloring-area" style="display: none;">
                <p>Looks great! Now color it in!</p>
                <div class="color-palette">
                    <div class="color-swatch active" style="background-color: #ff6f61;" data-color="#ff6f61"></div>
                    <div class="color-swatch" style="background-color: #ffd166;" data-color="#ffd166"></div>
                    <div class="color-swatch" style="background-color: #4db6ac;" data-color="#4db6ac"></div>
                    <div class="color-swatch" style="background-color: #7b1fa2;" data-color="#7b1fa2"></div>
                </div>
                <canvas id="coloring-canvas" width="300" height="300"></canvas>
            </div>
        </div>
    </div>

    <div id="myModal" class="modal">
        <div class="modal-content">
            <h3 id="modal-text"></h3>
            <button onclick="closeModal()">OK</button>
        </div>
    </div>

    <script>
        const pages = document.querySelectorAll('.page');
        const modal = document.getElementById('myModal');
        const modalText = document.getElementById('modal-text');
        
        let currentCategory = '';
        let availableQuestions = [];
        let isCorrect = false;
        let selectedColor = '#ff6f61';
        let partsColored = new Set();
        let currentImageParts = [];
        let coloringAnimationId = null;

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return { r, g, b };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function lighten(hex, amount = 0.2) {
            let { r, g, b } = hexToRgb(hex);
            r = Math.min(255, r + 255 * amount);
            g = Math.min(255, g + 255 * amount);
            b = Math.min(255, b + 255 * amount);
            return rgbToHex(r, g, b);
        }

        function darken(hex, amount = 0.2) {
            let { r, g, b } = hexToRgb(hex);
            r = Math.max(0, r - 255 * amount);
            g = Math.max(0, g - 255 * amount);
            b = Math.max(0, b - 255 * amount);
            return rgbToHex(r, g, b);
        }

        function createGradient(ctx, color, x1 = 0, y1 = 0, x2 = 0, y2 = 300) {
            const grad = ctx.createLinearGradient(x1, y1, x2, y2);
            grad.addColorStop(0, lighten(color, 0.15));
            grad.addColorStop(1, darken(color, 0.15));
            return grad;
        }

        function getRandomColor() {
            const colors = ['#ff6f61', '#ffd166', '#4db6ac', '#7b1fa2'];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        const gameDrawings = {
            'apple': (ctx, colors) => {
                const numParts = 3;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] },
                    { name: 'leaf', path: new Path2D(), color: defaultColors[1] },
                    { name: 'stem', path: new Path2D(), color: defaultColors[2] }
                ];
                // Enhanced body with more organic shape
                parts[0].path.moveTo(150, 45); parts[0].path.bezierCurveTo(225, 45, 270, 105, 270, 165); parts[0].path.bezierCurveTo(270, 225, 210, 270, 150, 270); parts[0].path.bezierCurveTo(90, 270, 30, 225, 30, 165); parts[0].path.bezierCurveTo(30, 105, 75, 45, 150, 45);
                // Leaf
                parts[1].path.moveTo(165, 45); parts[1].path.bezierCurveTo(180, 30, 210, 30, 225, 45); parts[1].path.bezierCurveTo(210, 60, 180, 60, 165, 45);
                // Stem
                parts[2].path.moveTo(143, 75); parts[2].path.bezierCurveTo(135, 45, 165, 45, 158, 75);
                // Add highlight for enhancement
                const highlight = new Path2D();
                highlight.arc(90, 90, 30, 0, Math.PI * 2);
                parts.push({ name: 'highlight', path: highlight, color: lighten(defaultColors[0], 0.3) });
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'triangle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(270, 270); path.lineTo(30, 270); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#ccc' }];
            },
            'circle': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.arc(150, 150, 128, 0, 2 * Math.PI);
                return [{ name: 'shape', path: path, color: defaultColor || '#ccc' }];
            },
            'square': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.rect(22, 22, 256, 256);
                return [{ name: 'shape', path: path, color: defaultColor || '#ccc' }];
            },
            'star': (ctx, colors) => {
                const defaultColor = Array.isArray(colors) ? colors[0] : colors;
                const path = new Path2D();
                path.moveTo(150, 30); path.lineTo(180, 110); path.lineTo(260, 110); path.lineTo(200, 160); path.lineTo(220, 240); path.lineTo(150, 200); path.lineTo(80, 240); path.lineTo(100, 160); path.lineTo(40, 110); path.lineTo(120, 110); path.closePath();
                return [{ name: 'shape', path: path, color: defaultColor || '#ccc' }];
            },
            'house': (ctx, colors) => {
                const numParts = 6;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'roof', path: new Path2D(), color: defaultColors[0] },
                    { name: 'walls', path: new Path2D(), color: defaultColors[1] },
                    { name: 'door', path: new Path2D(), color: defaultColors[2] },
                    { name: 'window1', path: new Path2D(), color: defaultColors[3] },
                    { name: 'window2', path: new Path2D(), color: defaultColors[4] },
                    { name: 'chimney', path: new Path2D(), color: defaultColors[5] }
                ];
                // Roof
                parts[0].path.moveTo(150, 45); parts[0].path.lineTo(30, 135); parts[0].path.lineTo(270, 135); parts[0].path.closePath();
                // Walls
                parts[1].path.rect(45, 135, 210, 135);
                // Door
                parts[2].path.rect(120, 210, 60, 60);
                // Window 1
                parts[3].path.rect(75, 165, 38, 38);
                // Window 2
                parts[4].path.rect(188, 165, 38, 38);
                // Chimney enhancement
                parts[5].path.rect(210, 75, 30, 60);
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'castle': (ctx, colors) => {
                const numParts = 6;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'mainWall', path: new Path2D(), color: defaultColors[0] },
                    { name: 'leftTower', path: new Path2D(), color: defaultColors[1] },
                    { name: 'rightTower', path: new Path2D(), color: defaultColors[2] },
                    { name: 'flag', path: new Path2D(), color: defaultColors[3] },
                    { name: 'door', path: new Path2D(), color: defaultColors[4] },
                    { name: 'battlement', path: new Path2D(), color: defaultColors[5] }
                ];
                // Main Wall
                parts[0].path.rect(60, 100, 180, 180);
                // Left Tower
                parts[1].path.rect(30, 45, 60, 235);
                // Right Tower
                parts[2].path.rect(210, 45, 60, 235);
                // Flag
                parts[3].path.moveTo(250, 60); parts[3].path.lineTo(265, 45); parts[3].path.lineTo(280, 60); parts[3].path.lineTo(265, 75); parts[3].path.closePath();
                // Door
                parts[4].path.rect(130, 200, 40, 80);
                // Battlement enhancement
                parts[5].path.rect(60, 90, 180, 10); parts[5].path.rect(70, 80, 20, 10); parts[5].path.rect(110, 80, 20, 10); parts[5].path.rect(150, 80, 20, 10); parts[5].path.rect(190, 80, 20, 10); parts[5].path.rect(210, 80, 20, 10);
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'car': (ctx, colors) => {
                const numParts = 6;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'body', path: new Path2D(), color: defaultColors[0] },
                    { name: 'roof', path: new Path2D(), color: defaultColors[1] },
                    { name: 'frontWheel', path: new Path2D(), color: defaultColors[2] },
                    { name: 'backWheel', path: new Path2D(), color: defaultColors[3] },
                    { name: 'window', path: new Path2D(), color: defaultColors[4] },
                    { name: 'headlight', path: new Path2D(), color: defaultColors[5] }
                ];
                // Body
                parts[0].path.moveTo(30, 180); parts[0].path.lineTo(270, 180); parts[0].path.lineTo(270, 240); parts[0].path.lineTo(30, 240); parts[0].path.closePath();
                // Roof
                parts[1].path.moveTo(75, 180); parts[1].path.lineTo(135, 120); parts[1].path.lineTo(225, 120); parts[1].path.lineTo(240, 180); parts[1].path.closePath();
                // Wheels
                parts[2].path.arc(90, 240, 30, 0, 2 * Math.PI);
                parts[3].path.arc(210, 240, 30, 0, 2 * Math.PI);
                // Window
                parts[4].path.rect(90, 130, 100, 30);
                // Headlight enhancement
                parts[5].path.arc(255, 200, 15, 0, 2 * Math.PI);
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'tree': (ctx, colors) => {
                const numParts = 3;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'trunk', path: new Path2D(), color: defaultColors[0] },
                    { name: 'leaves1', path: new Path2D(), color: defaultColors[1] },
                    { name: 'leaves2', path: new Path2D(), color: defaultColors[2] }
                ];
                // Trunk
                parts[0].path.rect(125, 180, 50, 90);
                // Leaves enhanced with layers
                parts[1].path.arc(150, 150, 120, 0, 2 * Math.PI);
                parts[2].path.arc(150, 120, 80, 0, 2 * Math.PI);
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'robot': (ctx, colors) => {
                const numParts = 4;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'head', path: new Path2D(), color: defaultColors[0] },
                    { name: 'body', path: new Path2D(), color: defaultColors[1] },
                    { name: 'antenna', path: new Path2D(), color: defaultColors[2] },
                    { name: 'eyes', path: new Path2D(), color: defaultColors[3] }
                ];
                parts[0].path.rect(100, 50, 100, 70);
                parts[1].path.rect(80, 120, 140, 120);
                parts[2].path.moveTo(150, 50); parts[2].path.lineTo(150, 30); parts[2].path.arc(150, 30, 10, 0, 2 * Math.PI);
                // Eyes enhancement
                parts[3].path.arc(130, 80, 10, 0, 2 * Math.PI); parts[3].path.arc(170, 80, 10, 0, 2 * Math.PI);
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            },
            'flower': (ctx, colors) => {
                const numParts = 4;
                const defaultColors = Array.isArray(colors) ? colors : Array(numParts).fill(colors);
                const parts = [
                    { name: 'petals', path: new Path2D(), color: defaultColors[0] },
                    { name: 'center', path: new Path2D(), color: defaultColors[1] },
                    { name: 'stem', path: new Path2D(), color: defaultColors[2] },
                    { name: 'leaf', path: new Path2D(), color: defaultColors[3] }
                ];
                parts[0].path.arc(150, 150, 120, 0, 2 * Math.PI);
                parts[1].path.arc(150, 150, 50, 0, 2 * Math.PI);
                parts[2].path.rect(140, 270, 20, 30);
                // Leaf enhancement
                parts[3].path.moveTo(140, 280); parts[3].path.bezierCurveTo(120, 260, 100, 280, 120, 300); parts[3].path.closePath();
                if (typeof colors === 'string') {
                    parts.forEach((part, i) => {
                        part.color = i % 2 === 0 ? lighten(colors, 0.05 * i) : darken(colors, 0.05 * i);
                    });
                }
                return parts;
            }
        };

        const allImages = Object.keys(gameDrawings);

        const gameData = {
            shapes: allImages.filter(img => ['apple', 'triangle', 'circle', 'square', 'star', 'robot', 'flower'].includes(img)),
            buildings_cars: allImages.filter(img => ['house', 'castle', 'car', 'tree'].includes(img))
        };

        function changePage(id) {
            pages.forEach(page => page.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }
        
        function startGame() {
            changePage('categories');
        }

        function showModal(text, duration = 1500) {
            modalText.innerHTML = text;
            modal.style.display = 'flex';
            setTimeout(closeModal, duration);
        }
        
        function closeModal() {
            modal.style.display = 'none';
        }

        function selectCategory(category) {
            currentCategory = category;
            availableQuestions = [...gameData[currentCategory]];
            document.getElementById('game-title').innerText = `Category: ${category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' & ')}`;
            changePage('game-page');
            loadQuestion();
        }

        function loadQuestion() {
            if (availableQuestions.length === 0) {
                // Refill the pool to make the game "endless"
                availableQuestions = [...gameData[currentCategory]];
                showModal("You've seen them all! Let's shuffle and play again!", 2000);
            }

            const randomIndex = Math.floor(Math.random() * availableQuestions.length);
            const correctImageName = availableQuestions[randomIndex];
            
            // Remove the selected question from the available pool
            availableQuestions.splice(randomIndex, 1);

            const randomCorrectColor = getRandomColor();
            const correctLabel = `${randomColorName(randomCorrectColor).toUpperCase()} ${correctImageName.toUpperCase()}`;
            document.getElementById('question-text').innerText = correctLabel;

            const grid = document.getElementById('image-grid');
            grid.innerHTML = '';
            
            const shuffledImages = getShuffledImages(correctImageName);
            
            shuffledImages.forEach(imageName => {
                const div = document.createElement('div');
                div.classList.add('canvas-option');
                div.dataset.answer = imageName;

                const canvas = document.createElement('canvas');
                const canvasSize = 200; 
                canvas.width = canvasSize;
                canvas.height = canvasSize;
                const ctx = canvas.getContext('2d');
                ctx.scale(canvasSize / 300, canvasSize / 300);

                const randomColor = (imageName === correctImageName) ? randomCorrectColor : getRandomColor();
                const parts = gameDrawings[imageName](ctx, randomColor);
                parts.forEach(part => {
                    ctx.fillStyle = createGradient(ctx, part.color);
                    ctx.fill(part.path);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.stroke(part.path);
                });

                const label = document.createElement('span');
                label.classList.add('image-label');
                label.innerText = `${randomColorName(randomColor).toUpperCase()} ${imageName.toUpperCase()}`;
                div.prepend(label);

                div.appendChild(canvas);
                div.onclick = () => checkAnswer(imageName, correctImageName, div);
                grid.appendChild(div);
            });

            document.getElementById('image-grid').style.display = 'grid';
            document.getElementById('coloring-area').style.display = 'none';
            isCorrect = false;
        }

        function getShuffledImages(correctImage) {
            const allImages = gameData[currentCategory];
            const otherImages = allImages.filter(img => img !== correctImage);
            const shuffledOthers = otherImages.sort(() => Math.random() - 0.5);
            
            const choices = [correctImage, ...shuffledOthers.slice(0, 3)];
            return choices.sort(() => Math.random() - 0.5);
        }

        function randomColorName(hex) {
            const colorMap = {
                '#ff6f61': 'ORANGE',
                '#ffd166': 'YELLOW',
                '#4db6ac': 'BLUE',
                '#7b1fa2': 'PURPLE'
            };
            return colorMap[hex] || 'UNKNOWN';
        }

        function checkAnswer(selected, correct, element) {
            if (isCorrect) return;

            if (selected.includes(correct)) {
                isCorrect = true;
                element.classList.add('correct');
                showModal("Correct! Great job!", 1000);
                playSound(800, 0.1);
                
                document.getElementById('image-grid').style.display = 'none';
                document.getElementById('coloring-area').style.display = 'flex';
                
                const coloringCanvas = document.getElementById('coloring-canvas');
                const ctx = coloringCanvas.getContext('2d');
                ctx.clearRect(0, 0, coloringCanvas.width, coloringCanvas.height);
                
                const shades = ['#888888', '#999999', '#aaaaaa', '#bbbbbb', '#cccccc', '#dddddd']; 
                currentImageParts = gameDrawings[correct](ctx, shades);
                
                // Initial draw of the image with outlines
                drawColoringCanvas();

                if (coloringAnimationId) {
                    cancelAnimationFrame(coloringAnimationId);
                }

                coloringCanvas.onclick = (event) => {
                    const rect = coloringCanvas.getBoundingClientRect();
                    const x = (event.clientX - rect.left) * (coloringCanvas.width / rect.width);
                    const y = (event.clientY - rect.top) * (coloringCanvas.height / rect.height);
                    
                    const partToColor = currentImageParts.find(part => {
                        return ctx.isPointInPath(part.path, x, y) && !partsColored.has(part.name);
                    });

                    if (partToColor) {
                        partsColored.add(partToColor.name);
                        playSound(440, 0.05);
                        animateColorFill(ctx, partToColor, selectedColor);
                    }
                };
                
                partsColored = new Set();
                animateColorableParts(ctx);
            } else {
                element.classList.add('wrong');
                showModal("Oops! Try again!", 1000);
                playSound(200, 0.3, 'sawtooth');
                setTimeout(() => element.classList.remove('wrong'), 1000);
            }
        }

        function drawColoringCanvas() {
            const coloringCanvas = document.getElementById('coloring-canvas');
            const ctx = coloringCanvas.getContext('2d');
            ctx.clearRect(0, 0, coloringCanvas.width, coloringCanvas.height);
            currentImageParts.forEach(part => {
                let fillStyle;
                if (part.targetColor) {
                    if (part.progress >= 1) {
                        fillStyle = createGradient(ctx, part.targetColor);
                    } else {
                        const grad = ctx.createLinearGradient(0, 0, 0, coloringCanvas.height);
                        grad.addColorStop(0, part.targetColor);
                        grad.addColorStop(part.progress, part.targetColor);
                        grad.addColorStop(part.progress, part.initialColor);
                        grad.addColorStop(1, part.initialColor);
                        fillStyle = grad;
                    }
                } else {
                    fillStyle = createGradient(ctx, part.color);
                }
                ctx.fillStyle = fillStyle;
                ctx.fill(part.path);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke(part.path);
            });
        }

        function animateColorFill(ctx, part, targetColor) {
            const duration = 1000; // Slower for flowing effect
            const startTime = performance.now();
            part.initialColor = part.color;
            part.targetColor = targetColor;
            part.progress = 0;

            const animate = (currentTime) => {
                const elapsed = currentTime - startTime;
                part.progress = Math.min(elapsed / duration, 1);
                
                drawColoringCanvas();
                
                if (part.progress < 1) {
                    coloringAnimationId = requestAnimationFrame(animate);
                } else {
                    part.color = targetColor;
                    part.targetColor = null;
                    part.initialColor = null;
                    part.progress = null;
                    drawColoringCanvas();
                    if (partsColored.size === currentImageParts.length) {
                        showModal("All done! Next one!", 1500);
                        setTimeout(nextQuestion, 1500);
                    }
                }
            };
            coloringAnimationId = requestAnimationFrame(animate);
        }

        let animationFrameId = null;
        function animateColorableParts(ctx) {
            function animate(timestamp) {
                // Clear and redraw canvas each frame to show pulse animation
                drawColoringCanvas();

                const time = timestamp * 0.001;
                currentImageParts.forEach(part => {
                    if (!partsColored.has(part.name)) {
                        const scale = 1 + Math.sin(time * 4) * 0.03;
                        ctx.save();
                        ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
                        ctx.scale(scale, scale);
                        ctx.translate(-ctx.canvas.width / 2, -ctx.canvas.height / 2);
                        ctx.fillStyle = `rgba(255, 255, 255, 0.4)`;
                        ctx.fill(part.path);
                        ctx.restore();
                    }
                });
                animationFrameId = requestAnimationFrame(animate);
            }
            animationFrameId = requestAnimationFrame(animate);
        }

        function nextQuestion() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            loadQuestion();
        }
        
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.onclick = () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                selectedColor = swatch.dataset.color;
            };
        });

        let audioContext = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(frequency, duration, type = 'sine', volume = 0.5) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            oscillator.start();
            setTimeout(() => oscillator.stop(), duration * 1000);
        }
    </script>
</body>
</html>